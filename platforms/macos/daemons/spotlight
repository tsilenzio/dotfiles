#!/usr/bin/env bash

# Spotlight volume indexing manager
#
# Controls which volumes Spotlight indexes using UUID-based local config.
# Preferences are stored in ~/.dotfiles/.state/spotlight/ so each macOS
# installation can have independent settings for shared volumes.
#
# Config: .state/spotlight/config — one UUID=on|off per line
# Labels: .state/spotlight/labels — UUID=VolumeName for display
#
# Volumes without a Volume UUID (e.g., NTFS) are skipped with a warning.
# The boot volume is always indexed regardless of config.
#
# Usage:
#   spotlight status              Show indexing status for all volumes
#   spotlight set <volume> on|off Set a volume's indexing mode
#   spotlight rebuild [volume]    Force Spotlight to re-index (default: /)
#   spotlight apply               Apply rules from config (daemon calls this)
#   spotlight install             Install LaunchDaemon and apply
#   spotlight uninstall           Remove LaunchDaemon

set -e

DAEMON_LABEL="com.dotfiles.spotlight"
DAEMON_PLIST="/Library/LaunchDaemons/$DAEMON_LABEL.plist"
INSTALLED_SCRIPT="/usr/local/libexec/dotfiles-spotlight"
LOG_TAG="dotfiles-spotlight"

# State directory — resolved at runtime so the installed copy works too
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
STATE_DIR="$DOTFILES_DIR/.state/spotlight"
CONFIG_FILE="$STATE_DIR/config"
LABELS_FILE="$STATE_DIR/labels"

# --- Logging (self-contained for daemon use) ---

if [[ -t 1 ]]; then
    _C_GREEN='\033[0;32m' _C_YELLOW='\033[1;33m'
    _C_BLUE='\033[0;34m' _C_RED='\033[0;31m' _C_NC='\033[0m'
else
    _C_GREEN='' _C_YELLOW='' _C_BLUE='' _C_RED='' _C_NC=''
fi

_syslog() { logger -t "$LOG_TAG" "$1" 2>/dev/null || true; }
_info()  { echo -e "${_C_BLUE}[info]${_C_NC} $1"; _syslog "info: $1"; }
_ok()    { echo -e "${_C_GREEN}[ok]${_C_NC} $1"; _syslog "ok: $1"; }
_warn()  { echo -e "${_C_YELLOW}[warn]${_C_NC} $1"; _syslog "warn: $1"; }
_err()   { echo -e "${_C_RED}[error]${_C_NC} $1"; _syslog "error: $1"; }

# --- Config helpers ---

ensure_state_dir() {
    [[ -d "$STATE_DIR" ]] || mkdir -p "$STATE_DIR"
}

# Get Volume UUID via diskutil. Returns empty string if unavailable.
get_volume_uuid() {
    local mount_point="$1"
    diskutil info -plist "$mount_point" 2>/dev/null \
        | plutil -extract VolumeUUID raw - 2>/dev/null || true
}

# Read a key from config file (UUID=value format)
config_get() {
    local uuid="$1"
    [[ -f "$CONFIG_FILE" ]] || return 0
    while IFS='=' read -r key value; do
        [[ "$key" == "$uuid" ]] && { echo "$value"; return; }
    done < "$CONFIG_FILE"
}

# Write a key to config file (creates or updates)
config_set() {
    local uuid="$1" value="$2"
    ensure_state_dir
    if [[ -f "$CONFIG_FILE" ]]; then
        # Remove existing entry
        local tmp="$CONFIG_FILE.tmp"
        while IFS= read -r line; do
            case "$line" in
                "$uuid="*) ;;
                *) echo "$line" ;;
            esac
        done < "$CONFIG_FILE" > "$tmp"
        mv "$tmp" "$CONFIG_FILE"
    fi
    echo "$uuid=$value" >> "$CONFIG_FILE"
}

# Store a human-readable label for a UUID
label_set() {
    local uuid="$1" name="$2"
    ensure_state_dir
    if [[ -f "$LABELS_FILE" ]]; then
        local tmp="$LABELS_FILE.tmp"
        while IFS= read -r line; do
            case "$line" in
                "$uuid="*) ;;
                *) echo "$line" ;;
            esac
        done < "$LABELS_FILE" > "$tmp"
        mv "$tmp" "$LABELS_FILE"
    fi
    echo "$uuid=$name" >> "$LABELS_FILE"
}

# Get the stored label for a UUID
label_get() {
    local uuid="$1"
    [[ -f "$LABELS_FILE" ]] || return 0
    while IFS='=' read -r key value; do
        [[ "$key" == "$uuid" ]] && { echo "$value"; return; }
    done < "$LABELS_FILE"
}

# --- Volume helpers ---

is_macos_system_volume() {
    [[ -f "$1/System/Library/CoreServices/SystemVersion.plist" ]]
}

get_macos_version() {
    /usr/libexec/PlistBuddy -c "Print :ProductVersion" \
        "$1/System/Library/CoreServices/SystemVersion.plist" 2>/dev/null || echo "?"
}

get_indexing_status() {
    local out
    out=$(mdutil -s "$1" 2>/dev/null) || { echo "unknown"; return; }
    case "$out" in
        *"Indexing enabled"*)  echo "on" ;;
        *"Indexing disabled"*) echo "off" ;;
        *)                     echo "unknown" ;;
    esac
}

set_indexing() {
    local vol="$1" desired="$2"
    local current
    current=$(get_indexing_status "$vol")
    [[ "$current" == "$desired" ]] && return 0
    if [[ "$desired" == "off" ]]; then
        # -d disables AND erases stale index data
        mdutil -d "$vol" >/dev/null 2>&1 || true
    else
        mdutil -i on "$vol" >/dev/null 2>&1 || true
    fi
}

# Resolve volume path from a user-supplied name or path.
# Tries: as-is, /Volumes/<name>, then exit with error.
resolve_volume() {
    local target="$1"
    if [[ -d "$target" ]]; then
        echo "$target"
    elif [[ -d "/Volumes/$target" ]]; then
        echo "/Volumes/$target"
    else
        return 1
    fi
}

# Find non-boot macOS volumes under /Volumes/
# Output: system_vol|data_vol|version
find_managed_volumes() {
    for vol in /Volumes/*/; do
        [[ ! -d "$vol" ]] && continue
        is_macos_system_volume "$vol" || continue
        local name data version
        name=$(basename "$vol")
        data="/Volumes/${name} - Data"
        version=$(get_macos_version "$vol")
        if [[ -d "$data" ]]; then
            echo "${vol%/}|${data}|${version}"
        else
            echo "${vol%/}||${version}"
        fi
    done
}

# --- Commands ---

cmd_apply() {
    _info "Applying Spotlight rules..."
    ensure_state_dir

    # Boot volume: always indexed
    local boot_status
    boot_status=$(get_indexing_status "/")
    if [[ "$boot_status" != "on" ]]; then
        _warn "Boot volume indexing was OFF — re-enabling"
        mdutil -i on / >/dev/null 2>&1
        mdutil -E / >/dev/null 2>&1
        _ok "Boot volume indexing restored (rebuild started)"
    else
        _ok "Boot volume: indexed"
    fi

    # Track handled volume paths to avoid double-processing
    local handled=""

    # Process detected macOS system volumes
    while IFS='|' read -r sys_vol data_vol version; do
        local name uuid mode
        name=$(basename "$sys_vol")
        handled="$handled|$sys_vol|$data_vol"

        # Get UUID from data volume (primary) or system volume (fallback)
        uuid=""
        [[ -n "$data_vol" ]] && uuid=$(get_volume_uuid "$data_vol")
        [[ -z "$uuid" ]] && uuid=$(get_volume_uuid "$sys_vol")

        if [[ -z "$uuid" ]]; then
            _warn "$name: no Volume UUID — skipping"
            continue
        fi

        # Update label mapping
        label_set "$uuid" "$name"

        # Read preference from local config
        mode=$(config_get "$uuid")

        # No config → default to off (non-boot macOS volumes)
        if [[ -z "$mode" ]]; then
            mode="off"
            config_set "$uuid" "off"
            _info "$name: registered as off (not booted)"
        fi

        case "$mode" in
            on)
                set_indexing "$sys_vol" "on"
                [[ -n "$data_vol" ]] && set_indexing "$data_vol" "on"
                _ok "$name: indexed"
                ;;
            *)
                set_indexing "$sys_vol" "off"
                [[ -n "$data_vol" ]] && set_indexing "$data_vol" "off"
                _ok "$name: disabled (not booted)"
                ;;
        esac
    done < <(find_managed_volumes)

    # Process any other mounted volume with config
    for vol in /Volumes/*/; do
        [[ ! -d "$vol" ]] && continue
        local vpath="${vol%/}"

        # Skip already handled and data partitions
        case "$handled" in
            *"|$vpath|"*|*"|$vpath") continue ;;
        esac
        local vname
        vname=$(basename "$vpath")
        [[ "$vname" == *" - Data" ]] && continue

        local uuid
        uuid=$(get_volume_uuid "$vpath")
        [[ -z "$uuid" ]] && continue

        local mode
        mode=$(config_get "$uuid")
        [[ -z "$mode" ]] && continue

        # Update label mapping
        label_set "$uuid" "$vname"

        case "$mode" in
            on)
                set_indexing "$vpath" "on"
                _ok "$vname: indexed"
                ;;
            *)
                set_indexing "$vpath" "off"
                _ok "$vname: disabled"
                ;;
        esac
    done

    _ok "Rules applied"
}

cmd_status() {
    echo "Spotlight Volume Status"
    echo "======================"
    echo ""

    # Boot volume
    local boot_status
    boot_status=$(get_indexing_status "/")
    echo "Boot volume (/):"
    echo "  Indexing: $boot_status (boot volume always indexed)"

    # Daemon status
    if launchctl list "$DAEMON_LABEL" &>/dev/null 2>&1; then
        echo "  Daemon:   installed"
    else
        echo "  Daemon:   not installed"
    fi
    echo ""

    # Track shown UUIDs to mark stale entries later
    local shown_uuids=""

    # Detected macOS volumes
    local found=false
    while IFS='|' read -r sys_vol data_vol version; do
        found=true
        local name sys_status uuid mode
        name=$(basename "$sys_vol")
        sys_status=$(get_indexing_status "$sys_vol")

        uuid=""
        [[ -n "$data_vol" ]] && uuid=$(get_volume_uuid "$data_vol")
        [[ -z "$uuid" ]] && uuid=$(get_volume_uuid "$sys_vol")
        mode=$(config_get "$uuid")

        echo "macOS $version — $name:"
        echo "  System:  indexing $sys_status"

        if [[ -n "$data_vol" ]]; then
            local data_status
            data_status=$(get_indexing_status "$data_vol")
            echo "  Data:    indexing $data_status"
        fi

        echo "  Config:  ${mode:-(unmanaged)}"
        [[ -n "$uuid" ]] && echo "  UUID:    $uuid"
        echo ""
        shown_uuids="$shown_uuids|$uuid"
    done < <(find_managed_volumes)

    if [[ "$found" == "false" ]]; then
        echo "No other macOS volumes found under /Volumes/."
        echo ""
    fi

    # Other mounted volumes with config
    for vol in /Volumes/*/; do
        [[ ! -d "$vol" ]] && continue
        is_macos_system_volume "$vol" && continue
        local vname="${vol%/}"
        vname=$(basename "$vname")
        [[ "$vname" == *" - Data" ]] && continue

        local uuid mode status
        uuid=$(get_volume_uuid "${vol%/}")
        [[ -z "$uuid" ]] && continue
        mode=$(config_get "$uuid")
        [[ -z "$mode" ]] && continue

        status=$(get_indexing_status "${vol%/}")
        echo "$vname:"
        echo "  Indexing: $status"
        echo "  Config:   $mode"
        echo "  UUID:     $uuid"
        echo ""
        shown_uuids="$shown_uuids|$uuid"
    done

    # Show config entries for volumes not currently mounted
    if [[ -f "$CONFIG_FILE" ]]; then
        local has_unmounted=false
        while IFS='=' read -r uuid mode; do
            [[ -z "$uuid" ]] && continue
            case "$shown_uuids" in
                *"|$uuid"*) continue ;;
            esac
            if [[ "$has_unmounted" == "false" ]]; then
                echo "Unmounted (in config):"
                has_unmounted=true
            fi
            local label
            label=$(label_get "$uuid")
            echo "  ${label:-$uuid}: $mode"
        done < "$CONFIG_FILE"
        [[ "$has_unmounted" == "true" ]] && echo ""
    fi
}

cmd_install() {
    if [[ "${AUTO_YES:-false}" != "true" ]]; then
        echo "Installing Spotlight volume daemon"
        echo "=================================="
        echo ""
        echo "This will:"
        echo "  1. Register detected volumes in local config"
        echo "  2. Install a LaunchDaemon to apply rules at boot + volume mount"
        echo "  3. Apply rules immediately"
        echo ""
        read -r -p "Continue? [Y/n]: " confirm
        if [[ "$confirm" =~ ^[Nn] ]]; then
            echo "Aborted."
            exit 0
        fi
        echo ""
    fi

    # Resolve this script's absolute path for installation
    local script_path
    script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Copy script to system location (independent of dotfiles location)
    _info "Installing script to $INSTALLED_SCRIPT"
    sudo mkdir -p "$(dirname "$INSTALLED_SCRIPT")"
    sudo cp "$script_path" "$INSTALLED_SCRIPT"
    sudo chmod 755 "$INSTALLED_SCRIPT"

    # Generate and install LaunchDaemon plist
    # Bake DOTFILES_DIR so the daemon can find config when running as root
    _info "Installing LaunchDaemon: $DAEMON_LABEL"
    sudo tee "$DAEMON_PLIST" > /dev/null << PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${DAEMON_LABEL}</string>
    <key>ProgramArguments</key>
    <array>
        <string>${INSTALLED_SCRIPT}</string>
        <string>apply</string>
    </array>
    <key>EnvironmentVariables</key>
    <dict>
        <key>DOTFILES_DIR</key>
        <string>${DOTFILES_DIR}</string>
    </dict>
    <key>RunAtLoad</key>
    <true/>
    <key>WatchPaths</key>
    <array>
        <string>/Volumes</string>
    </array>
    <key>StandardOutPath</key>
    <string>/var/log/dotfiles-spotlight.log</string>
    <key>StandardErrorPath</key>
    <string>/var/log/dotfiles-spotlight.log</string>
</dict>
</plist>
PLIST
    sudo chmod 644 "$DAEMON_PLIST"
    sudo chown root:wheel "$DAEMON_PLIST"

    # Load daemon
    _info "Loading daemon..."
    sudo launchctl bootout system/"$DAEMON_LABEL" 2>/dev/null || true
    sudo launchctl bootstrap system "$DAEMON_PLIST"
    _ok "Daemon installed and loaded"
    echo ""

    # Apply rules (registers detected volumes in config)
    cmd_apply
}

cmd_uninstall() {
    echo "Removing Spotlight volume daemon..."

    if sudo launchctl list "$DAEMON_LABEL" &>/dev/null 2>&1; then
        _info "Unloading daemon..."
        sudo launchctl bootout system/"$DAEMON_LABEL" 2>/dev/null || true
        _ok "Daemon unloaded"
    else
        echo "Daemon not loaded."
    fi

    if [[ -f "$DAEMON_PLIST" ]]; then
        _info "Removing plist: $DAEMON_PLIST"
        sudo rm -f "$DAEMON_PLIST"
    fi

    if [[ -f "$INSTALLED_SCRIPT" ]]; then
        _info "Removing script: $INSTALLED_SCRIPT"
        sudo rm -f "$INSTALLED_SCRIPT"
    fi

    _ok "Daemon removed"
    echo ""
    echo "Note: Config in $STATE_DIR was NOT removed."
    echo "Indexing state unchanged — run 'sudo mdutil -a -i on' to re-enable all."
}

# Apply a set operation for a resolved volume path and mode
_apply_set() {
    local vol="$1" mode="$2"
    local data_vol="${vol} - Data"
    local vname
    vname=$(basename "$vol")

    # Get UUID — prefer data volume, fall back to system volume
    local uuid=""
    [[ -d "$data_vol" ]] && uuid=$(get_volume_uuid "$data_vol")
    [[ -z "$uuid" ]] && uuid=$(get_volume_uuid "$vol")

    if [[ -z "$uuid" ]]; then
        _err "$vname: no Volume UUID — cannot manage this volume"
        _info "Only APFS, HFS+, FAT32, and ExFAT volumes are supported"
        return 1
    fi

    # Save config
    config_set "$uuid" "$mode"
    label_set "$uuid" "$vname"
    _ok "Set $vname → $mode"

    # Apply the change immediately
    case "$mode" in
        on)
            set_indexing "$vol" "on"
            [[ -d "$data_vol" ]] && set_indexing "$data_vol" "on"
            _info "Rebuilding index for $vname..."
            sudo mdutil -E "$vol" >/dev/null 2>&1 || true
            [[ -d "$data_vol" ]] && sudo mdutil -E "$data_vol" >/dev/null 2>&1 || true
            _ok "$vname: indexing enabled (rebuild started)"
            ;;
        off)
            # Boot volume safety net
            if [[ "$vol" == "/" || "$vol" == "/System/Volumes/Data" ]]; then
                _warn "$vname is the boot volume — stays indexed regardless"
                _info "Config set to 'off' so other boots won't index it"
            else
                set_indexing "$vol" "off"
                [[ -d "$data_vol" ]] && set_indexing "$data_vol" "off"
                _ok "$vname: indexing disabled (index erased)"
            fi
            ;;
    esac
}

# Interactive volume picker — shown when `set` is called with no args
_interactive_set() {
    # Collect volumes: path|name|mode
    local volumes=() vol_paths=() vol_modes=()

    # macOS system volumes
    while IFS='|' read -r sys_vol data_vol version; do
        local name uuid mode
        name=$(basename "$sys_vol")
        uuid=""
        [[ -n "$data_vol" ]] && uuid=$(get_volume_uuid "$data_vol")
        [[ -z "$uuid" ]] && uuid=$(get_volume_uuid "$sys_vol")
        [[ -z "$uuid" ]] && continue
        mode=$(config_get "$uuid")
        volumes+=("$name (macOS $version)")
        vol_paths+=("$sys_vol")
        vol_modes+=("${mode:---}")
    done < <(find_managed_volumes)

    # Other volumes (skip data partitions and system volumes)
    for vol in /Volumes/*/; do
        [[ ! -d "$vol" ]] && continue
        is_macos_system_volume "$vol" && continue
        local vpath="${vol%/}"
        local vname
        vname=$(basename "$vpath")
        [[ "$vname" == *" - Data" ]] && continue
        local uuid
        uuid=$(get_volume_uuid "$vpath")
        [[ -z "$uuid" ]] && continue
        local mode
        mode=$(config_get "$uuid")
        volumes+=("$vname")
        vol_paths+=("$vpath")
        vol_modes+=("${mode:---}")
    done

    if [[ ${#volumes[@]} -eq 0 ]]; then
        echo "No manageable volumes found."
        exit 0
    fi

    echo "Volumes:"
    echo ""
    local i
    for i in "${!volumes[@]}"; do
        local state="${vol_modes[$i]}"
        local display
        case "$state" in
            on)  display="on" ;;
            off) display="off" ;;
            *)   display="unmanaged" ;;
        esac
        printf "  %d. %-28s %s\n" "$((i + 1))" "${volumes[$i]}" "$display"
    done
    echo ""

    local choice
    read -r -p "Toggle volume [1-${#volumes[@]}, q to quit]: " choice

    if [[ "$choice" == "q" || -z "$choice" ]]; then
        echo "Cancelled."
        exit 0
    fi

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt ${#volumes[@]} ]]; then
        _err "Invalid choice: $choice"
        exit 1
    fi

    local idx=$((choice - 1))
    local selected_path="${vol_paths[$idx]}"
    local current="${vol_modes[$idx]}"
    local new_mode

    # Toggle: on→off, anything else→on
    if [[ "$current" == "on" ]]; then
        new_mode="off"
    else
        new_mode="on"
    fi

    echo ""
    _apply_set "$selected_path" "$new_mode"
}

cmd_set() {
    local target="${ARGS[1]:-}"
    local mode="${ARGS[2]:-}"

    # No args → interactive picker
    if [[ -z "$target" ]]; then
        _interactive_set
        return
    fi

    if [[ -z "$mode" ]]; then
        echo "Usage: $(basename "$0") set <volume> <on|off>"
        echo ""
        echo "Run '$(basename "$0") set' with no args for interactive mode."
        exit 1
    fi

    if [[ "$mode" != "on" && "$mode" != "off" ]]; then
        _err "Invalid mode: $mode (must be 'on' or 'off')"
        exit 1
    fi

    # Resolve the volume path
    local vol
    vol=$(resolve_volume "$target") || { _err "Volume not found: $target"; exit 1; }

    _apply_set "$vol" "$mode"
}

cmd_rebuild() {
    local target="${ARGS[1]:-/}"

    # Resolve volume path
    local vol
    vol=$(resolve_volume "$target") || { _err "Volume not found: $target"; exit 1; }

    local vname
    vname=$(basename "$vol")
    local status
    status=$(get_indexing_status "$vol")

    if [[ "$status" == "off" ]]; then
        _warn "$vname: indexing is disabled — enable first with 'set $target on'"
        exit 1
    fi

    _info "Rebuilding Spotlight index for $vname..."
    sudo mdutil -E "$vol" >/dev/null 2>&1
    _ok "$vname: rebuild started"

    # Also rebuild data partition if it exists
    local data_vol="${vol} - Data"
    if [[ -d "$data_vol" ]]; then
        sudo mdutil -E "$data_vol" >/dev/null 2>&1
        _ok "$(basename "$data_vol"): rebuild started"
    fi
}

cmd_info() {
    echo "name=Spotlight Volume Manager"
    echo "description=Controls which volumes are indexed"
    echo "label=$DAEMON_LABEL"
    echo "type=daemon"
    echo "plist=$DAEMON_PLIST"
    echo "files=$INSTALLED_SCRIPT"
}

# --- Main ---

# Parse global flags
AUTO_YES=false
ARGS=()
for arg in "$@"; do
    case "$arg" in
        --yes|-y) AUTO_YES=true ;;
        *) ARGS+=("$arg") ;;
    esac
done

case "${ARGS[0]:-}" in
    info)      cmd_info ;;
    apply)     cmd_apply ;;
    status)    cmd_status ;;
    set)       cmd_set ;;
    rebuild)   cmd_rebuild ;;
    install)   cmd_install ;;
    uninstall) cmd_uninstall ;;
    *)
        echo "Spotlight volume indexing manager"
        echo ""
        echo "Usage: $(basename "$0") <command>"
        echo ""
        echo "Commands:"
        echo "  status                    Show indexing status for all volumes"
        echo "  set                       Interactive volume picker"
        echo "  set <volume> <on|off>     Set a volume's indexing mode"
        echo "  rebuild [volume]          Force Spotlight to re-index (default: /)"
        echo "  apply                     Apply rules from config"
        echo "  install                   Install LaunchDaemon and apply"
        echo "  uninstall                 Remove LaunchDaemon"
        echo "  info                      Machine-readable metadata"
        echo ""
        echo "Examples:"
        echo "  $(basename "$0") set Code on            Index /Volumes/Code"
        echo "  $(basename "$0") set Code off           Stop indexing /Volumes/Code"
        echo "  $(basename "$0") set Sequoia on         Always index Sequoia"
        echo "  $(basename "$0") set Sequoia off        Only index when booted"
        echo "  $(basename "$0") rebuild                Rebuild boot volume index"
        echo "  $(basename "$0") rebuild Sequoia        Rebuild specific volume"
        exit 1
        ;;
esac
